# Extra Credit - Buffon's Needle & Random Walk

---

Two interesting python tasks I wrote for Coding 1 Extra Credits work. May take a little while to run.

---

## Buffon's Needle

**Goalï¼š**
Simulate dropping a needle of length L on parallel lines distance D apart (L â‰¤ D) and estimate Ï€.

- Simulate N independent drops; compute crossing probability pË†.
- Use formula p = 2L/(pi*D) to solve for Ï€Ë†.
- Vary N âˆˆ {10^3, 10^4, 10^5}; plot Ï€Ë† vs N with horizontal line at Ï€.
- Report absolute error and binomial confidence interval for p propagated to Ï€.

---

**My main ideas:**

- to simplify the problem, first we need to set a constant L and a constant D. I will set L=1 and D=2.<br>
- I will set the whole area formed by parallel lines to be a 10*10 square. In the first quadrant of the coordinate system.<br>
- Thus, the parallel lines can be set as: y=0, y=2, y=4, y=6, y=8, y=10.<br>
- Next, we need to set the needles. I will define the starting point of a needle as a cooridinate: (x_i,y_i). in which x_i and y_i are random floats generated by numpy.<br>
- to make sure the needle won't fall outside the 10*10 square, x_i and y_i should be inside the interval [1,9]. because the length of needles is L=1 here.<br>
- Then we need to define the ending point of the needle, and what "crossing" means.
- I will set another random variable: Î¸. <br>
The definition for Î¸: The ray along the positive x-axis will coincide with the line segment "needle" after rotating counterclockwise by the angle Î¸. <br>
Thus, Î¸ can range [0,2Ï€]. (I'm using radians here, not degrees.)<br>
- I set this to make sure I can compute the coordinate of the ending point as: 
(x_i+LcosÎ¸, y_i+LsinÎ¸).<br>
- in which L=1, so the coordinate of the ending point is simply (x_i+cosÎ¸, y_i+sinÎ¸).<br>
- Through this setting, we can make sure that wherever the starting/ending point of the needle is, the needle will never fall outside the 10*10 square.<br>
- And I define "crossing" as: 0 or 2 or 4 or 6 or 8 or 10 falls inside the interval [y_i,y_i+LsinÎ¸] or [y_i+LsinÎ¸,y_i].<br>
- repeat N times and compute crossing probability pË†=counter/N. (whenever there's a crossing, counter=counter+1)
- then, using p = 2L/(pi* D), we have pi^=2L/(p*D). in my case, 2L=D=2, so pi^=1/p.

---

## Random Walk

**Goalï¼š**
- Implement Random Walks in 1D, 2D, and 3D for T âˆˆ {100, 1000, 5000} steps

- Simulate the Random Walk for ğ‘… Repetitions

- Estimate the Return Probability for each dimension

- Plot the Estimated Probability vs Dimension for Different Values of ğ‘‡

- Extend to Higher Dimensions (Optional)

---

My main ideas:

- for 1D, it means that the point can only move left(-1) or move right(+1).
- we can def a function for 1D (n repetitions): a originally=0, and b = np.random.uniform(0,1), if b<0.5, then a moves left(a=a-1); if b>=0.5, then a moves right(a=a+1). and we loop this for n times.
- to check whether a moves to the original point, we can set a flag. flag originally=0, and if a=0 at some point, flag=1. and we only need to check if flag ends up being 1.
- then we loop the function for ğ‘… Repetitions and see the probability.
